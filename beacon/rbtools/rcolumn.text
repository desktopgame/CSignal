/Users/koya/Work/VSCode/beacon/beacon/src/beacon/util/string_buffer.c
    <89>string_buffer* ret = (string_buffer*)mem_malloc(sizeof(string_buffer), filename, lineno);
    <85>void string_buffer_vappendf(string_buffer * self, const char * message, va_list ap) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/util/test/xtest_group.c
    <80>void xtest_group_add(xtest_group* self, const char* name, xtest_runner runner) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/util/test/xtest.c
    <146>bool xtest_expect_vtrue(xtest* self, bool condition, bool isRecord, bool isThrow, const char* filename, int lineno, const char* fmt, va_list ap) {
    <138>bool xtest_expect_true(xtest* self, bool condition, bool isRecord, bool isThrow, const char* filename, int lineno, const char* fmt, ...) {
    <93>bool ret = xtest_expect_vtrue(self, condition, isRecord, isThrow, filename, lineno, fmt, ap);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/util/vector.c
    <89>vector_item* temp = (vector_item*)MEM_REALLOC(self->memory, SLOT_SIZE * newCapacitySize);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/util/bench_mark.c
    <103>//https://stackoverflow.com/questions/17250932/how-to-get-the-time-elapsed-in-c-in-milliseconds-windows
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/util/mem.c
    <95>static void* default_realloc(void * block, size_t newSize, const char * filename, int lineno) {
    <94>static void* default_realloc(void * block, size_t newSize, const char * filename, int lineno);
    <89>static void slot_check_init(const char* filename, int lineno, void* arena, size_t size) {
    <88>static void slot_check_init(const char* filename, int lineno, void* arena, size_t size);
    <85>void * mem_realloc(void * block, size_t newSize, const char * filename, int lineno) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/util/text.c
    <93>SG_errno_t text_strncpy(char * outChar, size_t index, const char * source, size_t dataSize) {
    <80>//https://stackoverflow.com/questions/2262484/calling-fdopen-bad-file-descriptor
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/parse/parser.c
    <80>parser * parser_parse_from_source_swap(const char * source, const char * info) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/type_interface.c
    <110>method* type_find_smethod(type* self, const char* name, vector* args, struct enviroment* env, int* outIndex) {
    <108>method * type_find_method(type * self, const char * name, vector * args, enviroment * env, int * outIndex) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/object.c
    <85>static object* object_mallocImpl(object_tag type, const char* filename, int lineno) {
    <84>static object* object_mallocImpl(object_tag type, const char* filename, int lineno);
    <81>object * object_string_malloc(const char * s, const char* filename, int lineno) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/script_method.c
    <95>void script_method_execute(script_method * self, method* parent, frame * fr, enviroment* env) {
    <87>vector_assign(sub->type_args_vec, (typeparams - i) - 1, vector_pop(fr->type_args_vec));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/type_cache.c
    <139>type_cache * type_cache_init(type_cache * self, class_loader * context, il_type * iltype, type * tp, namespace_ * scope, cache_kind kind) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/fqcn_cache.c
    <80>fqcn_cache* ret = (fqcn_cache*)mem_malloc(sizeof(fqcn_cache), filename, lineno);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/operator_overload.c
    <83>operator_overload* ret = (operator_overload*)MEM_MALLOC(sizeof(operator_overload));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/type/interface_impl.c
    <119>method * interface_find_method(interface_ * self, const char * name, vector * args, enviroment * env, int * outIndex) {
    <85>static void interface_method_flattenImpl(interface_* self, vector* dest, int depth) {
    <84>static void interface_method_flattenImpl(interface_* self, vector* dest, int depth);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/type/class_impl.c
    <113>constructor * class_find_rconstructor(class_ * self, vector * args, vector* typeargs, frame* fr, int* outIndex) {
    <112>method * class_find_smethod(class_ * self, const char * name, vector * args, enviroment * env, int * outIndex) {
    <111>method * class_find_method(class_ * self, const char * name, vector * args, enviroment * env, int * outIndex) {
    <101>constructor * class_find_constructor(class_ * self, vector * args, enviroment * env, int* outIndex) {
    <93>constructor * class_find_empty_constructor(class_ * self, enviroment * env, int * outIndex) {
    <87>object * class_new_instance(class_* self, frame* fr, vector* args, vector* type_args) {
    <85>void class_define_native_method(class_ * self, const char * name, native_impl impl) {
    <82>field * class_find_sfield_tree(class_ * self, const char * name, int * outIndex) {
    <82>method * class_get_impl_method(class_ * self, type * interType, int interMIndex) {
    <81>field * class_find_field_tree(class_ * self, const char * name, int * outIndex) {
    <81>return vector_at(self->smethod_list, self->smethod_list->length - (all - index));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/type/meta_impl.c
    <118>method * meta_find_method(vector * method_vec, const char * name, vector * ilargs, enviroment * env, int * outIndex) {
    <106>constructor* meta_find_rctor(vector* ctor_vec, vector* args, vector* typeargs, frame* fr, int* outIndex) {
    <102>constructor* meta_find_ctor(vector* ctor_vec, vector* ilargs, struct enviroment* env, int* outIndex) {
    <81>int meta_rcalc_score(vector* params, vector* args, vector* typeargs, frame* fr) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/class_loader.c
    <110>class_loader * class_loader_new_entry_point_from_source(const char * source, const char* contextDescription) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/script_context.c
    <84>class_loader_rsub(self->bootstrap_class_loader, "beacon/lang/StackTraceElement.bc");
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/native_method_ref.c
    <83>native_method_ref* ret = (native_method_ref*)MEM_MALLOC(sizeof(native_method_ref));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/method.c
    <85>vector_assign(a->type_args_vec, (typeparams - i) - 1, vector_pop(fr->type_args_vec));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/generic_type.c
    <108>generic_type_addargs(copy, generic_type_applyImpl(generic_type_typeargs_at(fr, e->virtual_type_index), fr));
    <99>//			if(generic_type_rule_valid(generic_type_rule(self, ilctx), generic_type_rule(other, ilctx))) {
    <99>//			if(generic_type_rule_valid(generic_type_rule(self, ilctx), generic_type_rule(other, ilctx))) {
    <95>generic_type_addargs(copy, vector_at(ccget_override()->type_args_list, e->virtual_type_index));
    <93>generic_type* generic_type_malloc(struct type* core_type, const char* filename, int lineno) {
    <90>static int generic_type_distanceForm(generic_type* self, generic_type* other, frame* fr) {
    <90>static int generic_type_distanceImpl(generic_type* self, generic_type* other, frame* fr) {
    <89>static int generic_type_distanceImpl(generic_type* self, generic_type* other, frame* fr);
    <89>static int generic_type_distanceForm(generic_type* self, generic_type* other, frame* fr);
    <86>generic_type* ret = (generic_type*)mem_malloc(sizeof(generic_type), filename, lineno);
    <84>//				generic_type_rule_polymorphic(generic_type_rule(other, ilctx), self, ilctx)) {
    <81>else if (self->tag == generic_type_tag_method) copy->u.method_ = self->u.method_;
    <80>int generic_type_rdistance(generic_type* self, generic_type* other, frame* fr) {
    <80>generic_type_addargs(copy, generic_type_receiver_at(fr, e->virtual_type_index));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/native_method.c
    <96>void native_method_execute(native_method * self, method * parent, frame * fr, enviroment* env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/cll/class_loader_ilload_factor_module_impl.c
    <105>static il_factor_assign_op* CLIL_assign_arithmetic(class_loader* self, ast* source, operator_type type) {
    <104>static il_factor_assign_op* CLIL_assign_arithmetic(class_loader* self, ast* source, operator_type type);
    <94>static il_factor_unary_op* CLIL_unary(class_loader* self, ast* source, ilunary_op_type type) {
    <94>static il_factor_binary_op* CLIL_binary(class_loader* self, ast* source, operator_type type) {
    <93>static il_factor_binary_op* CLIL_binary(class_loader* self, ast* source, operator_type type);
    <93>static il_factor_unary_op* CLIL_unary(class_loader* self, ast* source, ilunary_op_type type);
    <85>return il_factor_wrap_assign(CLIL_assign_arithmetic(self, source, operator_bit_and));
    <84>return il_factor_wrap_assign(CLIL_assign_arithmetic(self, source, operator_rshift));
    <84>return il_factor_wrap_assign(CLIL_assign_arithmetic(self, source, operator_lshift));
    <84>return il_factor_wrap_assign(CLIL_assign_arithmetic(self, source, operator_bit_or));
    <83>static il_factor_new_instance* CLIL_new_instance(class_loader* self, ast* source) {
    <82>static il_factor_new_instance* CLIL_new_instance(class_loader* self, ast* source);
    <81>return il_factor_wrap_assign(CLIL_assign_arithmetic(self, source, operator_mod));
    <81>return il_factor_wrap_assign(CLIL_assign_arithmetic(self, source, operator_div));
    <81>return il_factor_wrap_assign(CLIL_assign_arithmetic(self, source, operator_mul));
    <81>return il_factor_wrap_assign(CLIL_assign_arithmetic(self, source, operator_sub));
    <81>return il_factor_wrap_assign(CLIL_assign_arithmetic(self, source, operator_add));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/cll/class_loader_link_impl.c
    <109>CLBC_methods_impl(self, scope, iltype, tp, iltype->u.interface_->method_list, tp->u.interface_->method_list);
    <109>CLBC_methods_impl(self, scope, iltype, tp, iltype->u.class_->smethod_list, ((TYPE2CLASS(tp))->smethod_list));
    <107>CLBC_methods_impl(self, scope, iltype, tp, iltype->u.class_->method_list, ((TYPE2CLASS(tp))->method_list));
    <103>static void CLBC_interface_impl(class_loader * self, il_type * iltype, type * tp, namespace_ * scope) {
    <103>static void CLBC_interface_decl(class_loader * self, il_type * iltype, type * tp, namespace_ * scope) {
    <101>class_loader_report(self, "invalid field declaration: %s @%s\n", tp->u.class_->name, outField->name);
    <99>static void CLBC_class_decl(class_loader * self, il_type * iltype, type * tp, namespace_ * scope) {
    <99>static void CLBC_class_impl(class_loader * self, il_type * iltype, type * tp, namespace_ * scope) {
    <98>static void CLBC_enum_decl(class_loader * self, il_type * iltype, type * tp, namespace_ * scope) {
    <98>static void CLBC_enum_impl(class_loader * self, il_type * iltype, type * tp, namespace_ * scope) {
    <98>static void CLBC_interface_impl(class_loader* self, il_type* iltype, type* tp, namespace_* scope);
    <98>static void CLBC_interface_decl(class_loader* self, il_type* iltype, type* tp, namespace_* scope);
    <97>static void CLBC_enum_decl(class_loader * self, il_type * iltype, type * tp, namespace_ * scope);
    <97>static void CLBC_enum_impl(class_loader * self, il_type * iltype, type * tp, namespace_ * scope);
    <94>static void CLBC_class_decl(class_loader* self, il_type* iltype, type* tp, namespace_* scope);
    <94>static void CLBC_class_impl(class_loader* self, il_type* iltype, type* tp, namespace_* scope);
    <92>CLBC_fields_impl(self, scope, iltype->u.class_->sfield_list, (TYPE2CLASS(tp))->sfield_list);
    <90>CLBC_fields_impl(self, scope, iltype->u.class_->field_list, (TYPE2CLASS(tp))->field_list);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/cll/class_loader_ilload_stmt_module_impl.c
    <100>static il_stmt_inferenced_type_init * CLIL_inferenced_type_init(class_loader * self, ast * source) {
    <96>static il_stmt_inferenced_type_init* CLIL_inferenced_type_init(class_loader* self, ast* source);
    <92>il_stmt_inferenced_type_init* ret = il_stmt_inferenced_type_init_new(aname->u.string_value);
    <83>static il_stmt_variable_decl* CLIL_variable_decl(class_loader* self, ast* source) {
    <83>static il_stmt_variable_init* CLIL_variable_init(class_loader* self, ast* source) {
    <82>static il_stmt_variable_init* CLIL_variable_init(class_loader* self, ast* source);
    <82>static il_stmt_variable_decl* CLIL_variable_decl(class_loader* self, ast* source);
    <80>il_stmt_inferenced_type_init* ilinfer = CLIL_inferenced_type_init(self, source);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/cll/class_loader_ilload_impl.c
    <128>static void class_loader_ilload_namespace_body(class_loader* self, il_namespace* current, vector* parent, ast* namespace_body) {
    <127>static void class_loader_ilload_namespace_body(class_loader* self, il_namespace* current, vector* parent, ast* namespace_body);
    <120>static void class_loader_ilload_namespace_path_recursive(class_loader* self, ast* namespace_path, ast* namespace_body) {
    <119>static void class_loader_ilload_namespace_path_recursive(class_loader* self, ast* namespace_path, ast* namespace_body);
    <108>static void class_loader_ilload_abstract_class(class_loader* self, il_namespace* current, ast* class_decl) {
    <108>static il_class* class_loader_ilload_classImpl(class_loader* self, il_namespace* current, ast* class_decl) {
    <107>static void class_loader_ilload_interface(class_loader* self, il_namespace* current, ast* interface_decl) {
    <107>static il_class* class_loader_ilload_classImpl(class_loader* self, il_namespace* current, ast* class_decl);
    <107>static void class_loader_ilload_abstract_class(class_loader* self, il_namespace* current, ast* class_decl);
    <106>static void class_loader_ilload_interface(class_loader* self, il_namespace* current, ast* interface_decl);
    <100>static void class_loader_ilload_namespace(class_loader* self, vector* parent, ast* namespace_decl) {
    <100>static void class_loader_ilload_enum(class_loader * self, il_namespace * current, ast * enum_decl) {
    <99>static void class_loader_ilload_namespace(class_loader* self, vector* parent, ast* namespace_decl);
    <99>static void class_loader_ilload_class(class_loader* self, il_namespace* current, ast* class_decl) {
    <99>static void class_loader_ilload_identifier_list(class_loader * self, vector * list, ast * source) {
    <98>static void class_loader_ilload_class(class_loader* self, il_namespace* current, ast* class_decl);
    <96>static void class_loader_ilload_enum(class_loader* self, il_namespace* current, ast* enum_decl);
    <95>static void class_loader_ilload_identifier_list(class_loader* self, vector* list, ast* source);
    <94>class_loader_ilload_namespace_path_recursive(self, ast_at(namespace_path, i), namespace_body);
    <83>class_loader_ilload_namespace_path_recursive(self, namespace_path, namespace_body);
    <83>class_loader_ilload_namespace_body(self, iln, iln->namespace_list, namespace_body);
    <80>//static il_stmt* class_loader_ilload_bodyImpl(class_loader* self, ast* source);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/cll/class_loader_bcload_import_module_impl.c
    <82>for (int i = self->import_manager->info_vec->length; i < ilimports->length; i++) {
    <80>static void CLBC_import_internal(class_loader* self, vector* ilimports, int i) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/cll/class_loader_ilload_type_module_impl.c
    <98>static void CLIL_type_parameter_rule(struct class_loader* self, struct ast* source, vector* dest);
    <90>if (source->tag == ast_type_out_parameter) iltypeparam->kind = il_type_parameter_kind_out;
    <88>if (source->tag == ast_type_in_parameter) iltypeparam->kind = il_type_parameter_kind_in;
    <85>static void CLIL_type_parameter_rule(class_loader* self, ast* source, vector* dest) {
    <81>void CLIL_typename_list(class_loader * self, vector * dst, ast * typename_list) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/cll/class_loader_bcload_member_module_impl.c
    <157>class_loader_report(self, "illegal of parameter count, must be binary operator argument count is two.: %s#%s", type_name(tp), operator_tostring(opov->type));
    <156>class_loader_report(self, "illegal of parameter count, must be unary operator argument count is one.: %s#%s", type_name(tp), operator_tostring(opov->type));
    <155>static void CLBC_chain_super(class_loader * self, il_type * iltype, type * tp, il_constructor * ilcons, il_constructor_chain * ilchain, enviroment * env) {
    <154>static void CLBC_chain_root(class_loader * self, il_type * iltype, type * tp, il_constructor * ilcons, il_constructor_chain * ilchain, enviroment * env) {
    <154>static void CLBC_chain_auto(class_loader * self, il_type * iltype, type * tp, il_constructor * ilcons, il_constructor_chain * ilchain, enviroment * env) {
    <148>static void CLBC_chain_super(class_loader* self, il_type* iltype, type* tp, il_constructor* ilcons, il_constructor_chain* ilchain, enviroment* env);
    <147>static void CLBC_chain_root(class_loader* self, il_type* iltype, type* tp, il_constructor* ilcons, il_constructor_chain* ilchain, enviroment* env);
    <147>static void CLBC_chain_auto(class_loader* self, il_type* iltype, type* tp, il_constructor* ilcons, il_constructor_chain* ilchain, enviroment* env);
    <143>static void CLBC_chain(class_loader* self, il_type* iltype, type* tp, il_constructor* ilcons, il_constructor_chain* ilchain, enviroment* env) {
    <142>static void CLBC_chain(class_loader* self, il_type* iltype, type* tp, il_constructor* ilcons, il_constructor_chain* ilchain, enviroment* env);
    <128>void CLBC_methods_impl(class_loader* self, namespace_* scope, il_type* iltype, type* tp, vector* ilmethods, vector* sgmethods) {
    <115>static void CLBC_parameter_list(class_loader* self, namespace_* scope, vector* param_list, vector* sg_param_list) {
    <115>static void CLBC_parameter_list(class_loader* self, namespace_* scope, vector* param_list, vector* sg_param_liste);
    <115>constructor* emptyTarget = class_find_empty_constructor(classz->super_class->core_type->u.class_, env, &emptyTemp);
    <113>chainTarget = class_find_constructor(classz->super_class->core_type->u.class_, chain->argument_list, env, &temp);
    <113>static bool CLBC_test_operator_overlaod(class_loader* self, il_type* iltype, type* tp, operator_overload* opov) {
    <112>static bool CLBC_test_operator_overlaod(class_loader* self, il_type* iltype, type* tp, operator_overload* opov);
    <109>il_operator_overload* ilopov = (il_operator_overload*)vector_at(iltype->u.class_->operator_overload_list, i);
    <109>void CLBC_methods_decl(class_loader* self, il_type* iltype, type* tp, vector* ilmethods, namespace_* scope) {
    <107>void CLBC_fields_decl(class_loader* self, il_type* iltype, type* tp, vector* ilfields, namespace_* scope) {
    <105>class_loader_report(self, "abstract method should be defined on the abstract class: %s\n", method->name);
    <101>class_loader_report(self, "invalid field declaration: %s @%s\n", tp->u.class_->name, outField->name);
    <100>void CLBC_operator_overload_decl(class_loader* self, il_type* iltype, type* tp, namespace_* scope) {
    <100>void CLBC_operator_overload_impl(class_loader* self, il_type* iltype, type* tp, namespace_* scope) {
    <100>class_loader_report(self, "invalid parameter: %s#%s", type_name(tp), operator_tostring(opov->type));
    <100>class_loader_report(self, "invalid parameter: %s#%s", type_name(tp), operator_tostring(opov->type));
    <98>void CLBC_fields_impl(class_loader* self, namespace_* scope, vector* ilfields, vector* sgfields) {
    <98>method->return_gtype = import_manager_resolve(self->import_manager, scope, ilmethod->return_fqcn);
    <96>method->type = modifier_is_native(ilmethod->modifier) ? method_type_native : method_type_script;
    <94>opov->return_gtype = import_manager_resolve(self->import_manager, scope, ilopov->return_fqcn);
    <94>class_loader_report(self, "invalid implement: %s @%s\n", tp->u.class_->name, outMethod->name);
    <93>class_loader_report(self, "shouldn't define field of abstract or native: %s\n", field->name);
    <92>opcode_buf_add(env->buf, (vector_item)classz->super_class->core_type->u.class_->classIndex);
    <92>void CLBC_body(class_loader* self, vector* stmt_list, enviroment* dest, namespace_* range) {
    <91>il_constructor* ilcons = (il_constructor*)vector_at(iltype->u.class_->constructor_list, i);
    <90>class_loader_report(self, "must be public a access level of operator: %s", type_name(tp));
    <88>//class_loader_sgload_params(self, scope, ilcons->parameter_list, cons->parameter_list);
    <87>void CLBC_ctor_decl(class_loader* self, il_type* iltype, type* tp, namespace_* scope) {
    <84>type_parameter_list_dup(ilmethod->type_parameter_list, method->type_parameter_list);
    <83>CLBC_parameter_list(self, scope, ilmethod->parameter_list, method->parameter_list);
    <82>field->gtype = import_manager_resolve(self->import_manager, scope, ilfield->fqcn);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/cll/class_loader_bcload_impl.c
    <126>static void CLBC_attach_native_method(class_loader* self, il_type* ilclass, class_* classz, il_method* ilmethod, method* me) {
    <124>static void CLBC_attach_native_method(class_loader* self, il_type* iltype, class_* classz, il_method* ilmethod, method* me);
    <123>static void CLBC_register_interface(class_loader* self, namespace_* parent, il_type* iltype, type* tp, interface_* inter) {
    <122>static void CLBC_register_interface(class_loader* self, namespace_* parent, il_type* iltype, type* tp, interface_* inter);
    <113>static void CLBC_register_class(class_loader* self, namespace_* parent, il_type* iltype, type* tp, class_* cls) {
    <112>static void CLBC_register_class(class_loader* self, namespace_* parent, il_type* iltype, type* tp, class_* cls);
    <99>static void CLBC_namespace_list(class_loader* self, vector* ilnamespace_list, namespace_* parent) {
    <98>static type* CLBC_get_or_load_interface(class_loader* self, namespace_* parent, il_type* iltype) {
    <98>static void CLBC_namespace_list(class_loader* self, vector* ilnamespace_list, namespace_* parent);
    <97>class_loader_report(self, "should'nt implement equal interface a multiple: %s\n", ovinter->name);
    <97>static type* CLBC_get_or_load_interface(class_loader* self, namespace_* parent, il_type* iltype);
    <95>class_loader_report(self, "should'nt implement equal interface a multiple: %s\n", inter->name);
    <95>static void CLBC_namespace(class_loader* self, il_namespace* ilnamespace, namespace_* parent) {
    <95>type_parameter_list_dup(iltype->u.interface_->type_parameter_list, inter->type_parameter_list);
    <94>static void CLBC_namespace(class_loader* self, il_namespace* ilnamespace, namespace_* parent);
    <94>static type* CLBC_get_or_load_class(class_loader* self, namespace_* parent, il_type* iltype) {
    <94>type_parameter_list_dup(iltype->u.class_->type_parameter_list, outClass->type_parameter_list);
    <93>static type* CLBC_get_or_load_class(class_loader* self, namespace_* parent, il_type* iltype);
    <93>//	me->u.native_method->ref = native_method_ref_new(class_loader_sgload_debug_native_method);
    <89>type_parameter_list_dup(il_type_type_parameter_list(iltype), inter->type_parameter_list);
    <89>type_parameter_list_dup(iltype->u.class_->type_parameter_list, cls->type_parameter_list);
    <89>static void CLBC_type_list(class_loader* self, vector* iltype_list, namespace_* parent) {
    <88>static void CLBC_type_list(class_loader* self, vector* iltype_list, namespace_* parent);
    <88>static void CLBC_interface(class_loader * self, il_type * iltype, namespace_ * parent) {
    <84>static void CLBC_interface(class_loader* self, il_type* iltype, namespace_* parent);
    <84>generic_cache* e = (generic_cache*)vector_at(iltype->u.interface_->extends_list, i);
    <83>static void CLBC_enum(class_loader * self, il_type * iltype, namespace_ * parent) {
    <81>static void CLBC_debug_native_method(method* parent, frame* fr, enviroment* env);
    <81>static void CLBC_class(class_loader* self, il_type* iltype, namespace_* parent) {
    <81>static void CLBC_debug_native_method(method* parent, frame*fr, enviroment* env) {
    <80>static void CLBC_class(class_loader* self, il_type* iltype, namespace_* parent);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/cll/class_loader_ilload_member_module_impl.c
    <98>void CLIL_operator_overload(class_loader* self, il_type* current, ast* opov, access_level level) {
    <94>void CLIL_member_list(class_loader* self, il_type* current, ast* member, access_level level) {
    <92>void CLIL_ctor(class_loader* self, il_type* current, ast* constructor, access_level level) {
    <89>void CLIL_method(class_loader* self, il_type* current, ast* method, access_level level) {
    <87>void CLIL_field(class_loader* self, il_type* current, ast* field, access_level level) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/compile_context.c
    <81>return method_diff(cc_current()->abstract_method, cc_current()->concrete_method);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/constructor.c
    <86>object * constructor_new_instance(constructor * self, vector * args, frame * parent) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/env/import_manager.c
    <100>generic_type* import_manager_resolve(import_manager* self, namespace_* scope, generic_cache* fqcn) {
    <98>generic_type* import_manager_resolvef(import_manager* self, namespace_* scope, fqcn_cache* fqcn) {
    <88>parameterized->virtual_type_index = type_for_generic_index(container, fqcn->fqcn->name);
    <88>parameterized->virtual_type_index = type_for_generic_index(container, fqcn->fqcn->name);
    <82>parameterized->virtual_type_index = type_for_generic_index(container, fqcn->name);
    <82>parameterized->virtual_type_index = method_for_generic_index(m, fqcn->fqcn->name);
    <82>parameterized->virtual_type_index = type_for_generic_index(container, fqcn->name);
    <82>import_info* import_manager_import(import_manager * self, class_loader * target) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/vm/eval.c
    <81>class_loader* cll = class_loader_new_entry_point_from_source(source, "eval-top");
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/vm/vm.c
    <93>vector_push(self->value_stack, object_double_new((double)((int)SPD(self) % (int)SPD(self))));
    <89>vector_assign(sub->type_args_vec, (typeparams - i) - 1, vector_pop(self->type_args_vec));
    <85>constructor* ctor = (constructor*)vector_at(cls->constructor_list, constructorIndex);
    <82>method* m = class_get_impl_method(o->gtype->core_type->u.class_, tp, methodIndex);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/vm/symbol_table.c
    <92>symbol_entry* symbol_table_entry(symbol_table* self, generic_type* gtp, const char * name) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/main.c
    <82>while ((opt = getopt_long(argc, argv, "ta:i:r:o:", longopts, &longindex)) != -1) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/lib/beacon/lang/bc_object.c
    <84>class_define_native_method(objectClass, "nativeToString", bc_object_nativeToString);
    <82>static void bc_object_nativeToString(method* parent, frame* fr, enviroment* env) {
    <81>static void bc_object_nativeToString(method* parent, frame* fr, enviroment* env);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/lib/beacon/lang/bc_array.c
    <135>vm_native_throw(fr, exception_new_simplef(fr, "index must be less than size of array: %d - %d", srcOffset->u.int_, dstOffset->u.int_));
    <120>vm_native_throw(fr, exception_new_simplef(fr, "index must be positive: %d - %d", srcOffset->u.int_, dstOffset->u.int_));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/lib/beacon/lang/bc_exception.c
    <107>object* arr = bc_array_new(stackTraceElementClass->parent->generic_self, stackTraceElementVec->length, fr);
    <82>class_define_native_method(exceptionClass, "nativeInit", bc_exception_nativeInit);
    <81>static void bc_exception_nativeInit(method* parent, frame* fr, enviroment* env) {
    <80>static void bc_exception_nativeInit(method* parent, frame* fr, enviroment* env);
    <80>class_* stackTraceElementClass = namespace_get_class(lang, "StackTraceElement");
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/ast/ast_new_decl.c
    <134>ast * ast_new_method_decl(ast* amodifier, char * func_name, ast* atype_parameter, ast * parameter_list, ast* body, ast* return_type) {
    <125>ast * ast_new_method_decl_empty_params(ast* amodifier, char * func_name, ast* atype_parameter, ast* body, ast* return_type) {
    <104>ast * ast_new_function_decl(char * function_name, ast * parameter_list, ast * body, ast * return_type) {
    <103>static ast* ast_new_class_declImpl(ast* aclass_name, ast* extend_list, ast* member_list, ast_tag tag) {
    <102>static ast* ast_new_class_declImpl(ast* aclass_name, ast* extend_list, ast* member_list, ast_tag tag);
    <102>return ast_new_method_decl(amodifier, func_name, atype_parameter, ast_new_blank(), body, return_type);
    <98>ast * ast_new_parameter_list(ast* atypename, char * parameter_access_name, ast * parameter_list) {
    <98>ast * ast_new_interface_decl(ast* ainterface_name, ast* super_interface_list, ast * member_list) {
    <96>ast* ast_new_operator_overload(operator_type type, ast* aparam_list, ast* abody, ast* areturn) {
    <95>ast * ast_new_function_decl_empty_params(char * function_name, ast * body, ast * return_type) {
    <94>return ast_new_class_declImpl(aclass_name, extend_list, member_list, ast_abstract_class_decl);
    <91>ast * ast_new_constructor_decl(ast * parameter_list, ast * constructor_chain, ast * body) {
    <89>ast * ast_new_constructor_chain(constructor_chain_type chain_type, ast * argument_list) {
    <88>ast* ast_new_abstract_class_decl(ast* aclass_name, ast* extend_list, ast* member_list) {
    <85>return ast_new_class_declImpl(aclass_name, extend_list, member_list, ast_class_decl);
    <80>ast * ast_new_class_decl(ast* aclass_name, ast* extend_list, ast* member_list) {
    <80>//	ast_push(ret, ast_new_parameter(parameter_type_name, parameter_access_name));
    <80>return ast_new_function_decl(function_name, ast_new_blank(), body, return_type);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/ast/ast_new_stmt.c
    <93>ast * ast_new_if_elif_list_else(ast * cond, ast * trueBody, ast * elifList, ast * elseBody) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/stmt/il_stmt_variable_decl_impl.c
    <95>il_stmt_variable_decl* ret = (il_stmt_variable_decl*)MEM_MALLOC(sizeof(il_stmt_variable_decl));
    <89>import_manager_resolve(ccget_class_loader()->import_manager, cc_namespace(), self->fqcn),
    <88>//generic_cache_gtype(self->fqcn, (namespace_*)vector_top(ilctx->namespace_vec), ilctx),
    <87>void il_stmt_variable_decl_load(il_stmt_variable_decl * self, struct enviroment* env) {
    <85>void il_stmt_variable_decl_generate(il_stmt_variable_decl * self, enviroment * env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/stmt/il_stmt_assert_impl.c
    <92>opcode_buf_add(env->buf, namespace_get_type(namespace_lang(), "Exception")->absolute_index);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/stmt/il_stmt_variable_init_impl.c
    <108>generic_type* gb = import_manager_resolve(ccget_class_loader()->import_manager, cc_namespace(), self->fqcn);
    <107>//generic_type* gb = generic_cache_gtype(self->fqcn, (namespace_*)vector_top(ilctx->namespace_vec), ilctx);
    <95>il_stmt_variable_init* ret = (il_stmt_variable_init*)MEM_MALLOC(sizeof(il_stmt_variable_init));
    <89>import_manager_resolve(ccget_class_loader()->import_manager, cc_namespace(), self->fqcn),
    <88>//generic_cache_gtype(self->fqcn, (namespace_*)vector_top(ilctx->namespace_vec), ilctx),
    <85>void il_stmt_variable_init_generate(il_stmt_variable_init * self, enviroment * env) {
    <81>void il_stmt_variable_init_load(il_stmt_variable_init * self, enviroment * env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/stmt/il_stmt_inferenced_type_init_impl.c
    <116>il_stmt_inferenced_type_init* ret = (il_stmt_inferenced_type_init*)MEM_MALLOC(sizeof(il_stmt_inferenced_type_init));
    <99>void il_stmt_inferenced_type_init_generate(il_stmt_inferenced_type_init * self, enviroment * env) {
    <95>void il_stmt_inferenced_type_init_load(il_stmt_inferenced_type_init * self, enviroment * env) {
    <88>void il_stmt_inferenced_type_init_dump(il_stmt_inferenced_type_init * self, int depth) {
    <84>il_stmt_inferenced_type_init * il_stmt_inferenced_type_init_new(const char * name) {
    <82>il_stmt * il_stmt_wrap_inferenced_type_init(il_stmt_inferenced_type_init * self) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/stmt/il_stmt_try_impl.c
    <116>generic_type* exgType = import_manager_resolve(ccget_class_loader()->import_manager, cc_namespace(), ilcatch->fqcn);
    <115>//generic_type* exgType = generic_cache_gtype(ilcatch->fqcn, (namespace_*)vector_top(ilctx->namespace_vec), ilctx);
    <113>generic_type* exgType = import_manager_resolve(ccget_class_loader()->import_manager, cc_namespace(), self->fqcn);
    <80>int exIndex = symbol_table_entry(env->sym_table, exgType, ilcatch->name)->index;
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/il_operator_overload.c
    <92>il_operator_overload* ret = (il_operator_overload*)MEM_MALLOC(sizeof(il_operator_overload));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/il_type_parameter.c
    <83>il_type_parameter* ret = (il_type_parameter*)MEM_MALLOC(sizeof(il_type_parameter));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/il_constructor_chain.c
    <92>il_constructor_chain* ret = (il_constructor_chain*)MEM_MALLOC(sizeof(il_constructor_chain));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_member_op_impl.c
    <122>generic_type* ref = import_manager_resolvef(ccget_class_loader()->import_manager, cc_namespace(), ilvar->u.static_->fqcn);
    <89>il_factor_member_op* ret = (il_factor_member_op*)MEM_MALLOC(sizeof(il_factor_member_op));
    <84>generic_type* il_factor_member_op_eval(il_factor_member_op* self, enviroment* env) {
    <83>static void il_factor_member_op_check(il_factor_member_op* self, enviroment* env) {
    <82>static void il_factor_member_op_check(il_factor_member_op* self, enviroment* env);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_new_instance_impl.c
    <99>generic_type* arg = import_manager_resolve(ccget_class_loader()->import_manager, scope, e->gcache);
    <98>il_factor_new_instance* ret = (il_factor_new_instance*)MEM_MALLOC(sizeof(il_factor_new_instance));
    <92>generic_type* il_factor_new_instance_eval(il_factor_new_instance * self, enviroment * env) {
    <90>static void il_factor_new_instance_find(il_factor_new_instance * self, enviroment * env) {
    <89>static void il_factor_new_instance_find(il_factor_new_instance * self, enviroment * env);
    <87>void il_factor_new_instance_generate(il_factor_new_instance * self, enviroment * env) {
    <83>void il_factor_new_instance_load(il_factor_new_instance * self, enviroment * env) {
    <83>char* il_factor_new_instance_tostr(il_factor_new_instance* self, enviroment* env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_string_impl.c
    <80>il_factor_string* ret = (il_factor_string*)MEM_MALLOC(sizeof(il_factor_string));
    <80>generic_type* il_factor_string_eval(il_factor_string * self, enviroment * env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/variable/il_factor_variable_static_impl.c
    <107>il_factor_variable_static* ret = (il_factor_variable_static*)MEM_MALLOC(sizeof(il_factor_variable_static));
    <98>generic_type* il_factor_variable_static_eval(il_factor_variable_static * self, enviroment * env) {
    <91>void il_factor_variable_static_generate(il_factor_variable_static* self, enviroment* env) {
    <91>char* il_factor_variable_static_tostr(il_factor_variable_static * self, enviroment * env) {
    <89>void il_factor_variable_static_load(il_factor_variable_static * self, enviroment * env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/variable/il_factor_variable_local_impl.c
    <104>il_factor_variable_local* ret = (il_factor_variable_local*)MEM_MALLOC(sizeof(il_factor_variable_local));
    <96>generic_type* il_factor_variable_local_eval(il_factor_variable_local * self, enviroment * env) {
    <89>void il_factor_variable_local_generate(il_factor_variable_local* self, enviroment* env) {
    <89>char* il_factor_variable_local_tostr(il_factor_variable_local * self, enviroment * env) {
    <87>void il_factor_variable_local_load(il_factor_variable_local * self, enviroment * env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_instanceof_impl.c
    <113>generic_type* gtype = import_manager_resolve(ccget_class_loader()->import_manager, cc_namespace(), self->gcache);
    <92>il_factor_instanceof* ret = (il_factor_instanceof*)MEM_MALLOC(sizeof(il_factor_instanceof));
    <86>generic_type* il_factor_instanceof_eval(il_factor_instanceof* self, enviroment* env) {
    <81>void il_factor_instanceof_generate(il_factor_instanceof* self, enviroment* env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/invoke/il_factor_invoke_static_impl.c
    <101>il_factor_invoke_static* ret = (il_factor_invoke_static*)MEM_MALLOC(sizeof(il_factor_invoke_static));
    <99>generic_type* instanced_type = (generic_type*)vector_at(self->type_args, rgtp->virtual_type_index);
    <94>generic_type* il_factor_invoke_static_eval(il_factor_invoke_static * self, enviroment * env) {
    <93>static void il_factor_invoke_static_check(il_factor_invoke_static * self, enviroment * env) {
    <92>static void il_factor_invoke_static_check(il_factor_invoke_static * self, enviroment * env);
    <87>void il_factor_invoke_static_generate(il_factor_invoke_static* self, enviroment* env) {
    <85>void il_factor_invoke_static_load(il_factor_invoke_static * self, enviroment * env) {
    <85>char* il_factor_invoke_static_tostr(il_factor_invoke_static* self, enviroment* env) {
    <83>static void resolve_non_default(il_factor_invoke_static * self, enviroment * env) {
    <82>static void resolve_non_default(il_factor_invoke_static * self, enviroment * env);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/invoke/il_factor_invoke_bound_impl.c
    <99>generic_type* instanced_type = (generic_type*)vector_at(self->type_args, rgtp->virtual_type_index);
    <98>il_factor_invoke_bound* ret = (il_factor_invoke_bound*)MEM_MALLOC(sizeof(il_factor_invoke_bound));
    <92>generic_type* il_factor_invoke_bound_eval(il_factor_invoke_bound * self, enviroment * env) {
    <91>static void il_factor_invoke_bound_check(il_factor_invoke_bound * self, enviroment * env) {
    <90>static void il_factor_invoke_bound_check(il_factor_invoke_bound * self, enviroment * env);
    <85>void il_factor_invoke_bound_generate(il_factor_invoke_bound* self, enviroment* env) {
    <83>self->m = class_find_method(TYPE2CLASS(ctype), self->name, self->args, env, &temp);
    <83>void il_factor_invoke_bound_load(il_factor_invoke_bound * self, enviroment * env) {
    <83>char* il_factor_invoke_bound_tostr(il_factor_invoke_bound* self, enviroment* env) {
    <82>static void resolve_non_default(il_factor_invoke_bound * self, enviroment * env) {
    <81>static void resolve_non_default(il_factor_invoke_bound * self, enviroment * env);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/invoke/il_factor_invoke_impl.c
    <113>generic_type* instanced_type = (generic_type*)vector_at(receivergType->type_args_list, rgtp->virtual_type_index);
    <99>generic_type* instanced_type = (generic_type*)vector_at(self->type_args, rgtp->virtual_type_index);
    <92>//self->m = class_find_method(TYPE2CLASS(ctype), self->name, self->args, env, cache, &temp);
    <80>il_factor_invoke* ret = (il_factor_invoke*)MEM_MALLOC(sizeof(il_factor_invoke));
    <80>generic_type* il_factor_invoke_eval(il_factor_invoke * self, enviroment * env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_unary_op_impl.c
    <86>il_factor_unary_op* ret = (il_factor_unary_op*)MEM_MALLOC(sizeof(il_factor_unary_op));
    <84>generic_type* il_factor_unary_op_eval(il_factor_unary_op * self, enviroment * env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_assign_op_impl.c
    <89>il_factor_assign_op* ret = (il_factor_assign_op*)MEM_MALLOC(sizeof(il_factor_assign_op));
    <84>generic_type* il_factor_assign_op_eval(il_factor_assign_op* self, enviroment* env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_as_impl.c
    <105>generic_type* to = generic_cache_gtype(self->fqcn, (namespace_*)vector_top(ilctx->namespace_vec), ilctx);
    <83>return import_manager_resolve(ccget_class_loader()->import_manager, n, self->fqcn);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_cast_impl.c
    <96>//	return generic_cache_gtype(self->fqcn, (namespace_*)vector_top(ilctx->namespace_vec), ilctx);
    <96>return import_manager_resolve(ccget_class_loader()->import_manager, cc_namespace(), self->fqcn);
    <91>//	type* t = generic_cache_type(self->fqcn, (namespace_*)vector_top(ilctx->namespace_vec));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_double_impl.c
    <80>il_factor_double* ret = (il_factor_double*)MEM_MALLOC(sizeof(il_factor_double));
    <80>generic_type* il_factor_double_eval(il_factor_double * self, enviroment * env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_binary_op_impl.c
    <89>il_factor_binary_op* ret = (il_factor_binary_op*)MEM_MALLOC(sizeof(il_factor_binary_op));
    <86>generic_type* il_factor_binary_op_eval(il_factor_binary_op * self, enviroment * env) {
    <84>char* il_factor_binary_op_tostr_simple(il_factor_binary_op* self, enviroment* env) {
    <84>bool il_factor_binary_op_double_double(il_factor_binary_op* self, enviroment* env) {
    <80>void il_factor_binary_op_generate(il_factor_binary_op * self, enviroment* env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_call_op_impl.c
    <84>static void il_factor_invoke_bound_check(il_factor_call_op* self, enviroment* env) {
    <83>static void il_factor_invoke_bound_check(il_factor_call_op* self, enviroment* env);
    <83>il_factor_call_op* ret = (il_factor_call_op*)MEM_MALLOC(sizeof(il_factor_call_op));
    <81>static void il_factor_member_op_check(il_factor_call_op* self, enviroment* env) {
    <80>static void il_factor_member_op_check(il_factor_call_op* self, enviroment* env);
    <80>generic_type* il_factor_call_op_eval(il_factor_call_op* self, enviroment* env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/binary/il_factor_logic_op_impl.c
    <86>il_factor_logic_op* ret = (il_factor_logic_op*)MEM_MALLOC(sizeof(il_factor_logic_op));
    <82>generic_type* il_factor_logic_op_eval(il_factor_logic_op* self, enviroment* env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/binary/il_factor_compare_op_impl.c
    <92>il_factor_compare_op* ret = (il_factor_compare_op*)MEM_MALLOC(sizeof(il_factor_compare_op));
    <88>generic_type* il_factor_compare_op_eval(il_factor_compare_op * self, enviroment * env) {
    <81>void il_factor_compare_op_generate(il_factor_compare_op* self, enviroment* env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/binary/il_factor_arithmetic_op_impl.c
    <101>il_factor_arithmetic_op* ret = (il_factor_arithmetic_op*)MEM_MALLOC(sizeof(il_factor_arithmetic_op));
    <94>generic_type* il_factor_arithmetic_op_eval(il_factor_arithmetic_op * self, enviroment * env) {
    <87>void il_factor_arithmetic_op_generate(il_factor_arithmetic_op* self, enviroment* env) {
    <85>char* il_factor_arithmetic_op_tostr(il_factor_arithmetic_op* self, enviroment* env) {
    <83>void il_factor_arithmetic_op_load(il_factor_arithmetic_op* self, enviroment* env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/binary/il_factor_shift_op_impl.c
    <86>il_factor_shift_op* ret = (il_factor_shift_op*)MEM_MALLOC(sizeof(il_factor_shift_op));
    <84>generic_type* il_factor_shift_op_eval(il_factor_shift_op * self, enviroment * env) {
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/factor/il_factor_variable_impl.c
    <86>il_factor_variable* ret = (il_factor_variable*)MEM_MALLOC(sizeof(il_factor_variable));
    <84>generic_type* il_factor_variable_eval(il_factor_variable * self, enviroment * env) {
    <81>static void il_factor_variable_check(il_factor_variable* self, enviroment* env) {
    <80>static void il_factor_variable_check(il_factor_variable* self, enviroment* env);
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/il_type_argument.c
    <90>e->gtype = import_manager_resolve(ccget_class_loader()->import_manager, scope, e->gcache);
    <80>il_type_argument* ret = (il_type_argument*)MEM_MALLOC(sizeof(il_type_argument));
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/il_type_interface.c
    <117>return self->tag == iltype_interface ? self->u.interface_->type_parameter_list : self->u.class_->type_parameter_list;
/Users/koya/Work/VSCode/beacon/beacon/src/beacon/il/il_factor_interface.c
    <87>void il_factor_type_args_tostr(string_buffer* sb, vector* type_args, enviroment* env) {
