仮想マシンの実装に関するメモ  

# 仮想マシン(virtual machine)
**オペコード**の一覧を実行する関数のこと?  
beaconではそのように扱っています

# オペコード
プログラムで実行される手続きの最小単位  
オペコードには引数として**オペランド**がついてくる場合もある。  

例えば invokevirtual のオペランドは int型の整数であり、  
これが何番目のメソッドであるかを表します。  

実際には、オペコードとオペランドは一つのリストにごちゃまぜに入っています。  
今のところbeacon VM は入力されるオペコードを完全に信頼しているので、  
(つまり、ベリファイアなどは存在しない)  

例えば invokevirtual の次の要素は int型にキャストされます。  
同様のことはほかの命令についても言えます。  
なので信頼できないバイトコードが入力されたらなにが起きるかわかりません。

# スタックフレーム
オペコードとオペランドはコンパイル時に決定して不変です。  
これだけでは代入などを行うことが出来ません。  

beaconでは関数が呼び出されるたびに新しいVMを作成します。  
(これは vm 構造体自体がスタックフレームを表しているからです。)  

スタックフレームには次のものが含まれます。    
* 実行中の位置  
* 親フレーム  
* 子フレーム  
* **参照リスト**
* **演算リスト(スタック?)**

# 参照リスト
参照スタックは変数を添え字で管理します。  
例えば store 0 が実行されると、  
参照リストの 0 番目 に 演算リストからポップしてきた値を格納します。  

これについては一般的にどう呼ばれているのかわからないので、  
勝手に参照リストと呼称しています。  
(もしかしたらこんなの必要ないのかもしれません)

参照リストは**シンボルテーブル**と合わせて使用されます。  

書き込み(store)
--
    int a = 0

この式が IL形式に変換されるとき、  
同時にシンボルテーブルに a を登録します。

登録すると戻り値として symbol_entry を得られます。  
(symbol_entry は添え字と型のペアです。)  

これを store/load に使用します。  
シンボルテーブルは内部にカウンタを持っていて登録されるたびに +1 されます。  

読み込み(load)
--
    callFunc(a)
このようなコードを変換するとき、  
最初にシンボルテーブルから a を探します。

見つからなかったならエラーとみなされます。  
(まだそういう風に実装してませんが)  

見つかったなら load 命令に  
symbol_entry の添え字を渡します。

ちなみにメソッドの読み込み時には  
仮引数を最初にシンボルテーブル順番に登録していきます。

# 演算リスト
例えば iadd という命令では、  
このリストから二つポップしてその結果を再びプッシュします。  
    
ほかにも関数呼び出しのときには  
実引数の一覧を順番にこのリストにプッシュしていきます。  

メソッドが開始すると引数の数だけポップして  
上記の参照スタックに順序よく当てはめていきます。

# 環境
beaconではVMを実行するときに、  
enviroment を渡します。  

これが **オペコードの一覧** や **定数プール** 等を持っています。  
VMは実行時に変化するのに対して、  
環境はコンパイルされてから不変です。  

# 定数プール
リテラルとして記述できるオブジェクトは、  
ILに変換するときにプールに登録して  
実行するときにはプールの中で何番目であるかという添え字をプッシュします。  

(メソッド呼び出しにも言えることですが、  
正規化した形式に変換する必要があるのは、  
そうしないとファイルへ書き出すことが出来ないためです。)  

これはただのリストです。  

# スタックフレームの連鎖
上述の通りスタックフレームは関数が呼ばれるたびに積まれていきます。  
スタックフレームは自身の親と子を参照できますが、  
これはGCや例外を実装するときに便利です。


# GC
スタックフレームのルートはmainファイルです。  
ここからたどれる全てのスタックフレームを巡回して、  
次のオブジェクトをマークします。
* 参照リスト
* 演算リスト
* 静的フィールド
* それ自体に定義されるフィールド

# 例外
例外は throw 命令で実装されます。

(後で書く...)
