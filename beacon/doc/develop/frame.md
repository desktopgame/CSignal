# frame
frameは現在実行中の`スタックトレース`を表します。

````
*-------------*
|frame(struct)|
|-pc          | <-- program counter
|-exception   | <-- thrown latest exception object
|-parent      | <-- parent
|-value_stack | <-- argument, operator
|-ref_stack   | <-- local variables
|-children    | <-- children
*-------------*
````

# プログラムの実行
プログラムを実行するにはコンパイル済みのバイトコードが必要になります。  
これと`定数プール`、`シンボルテーブル`を持っているのが`enviroment`です。  
これはコンパイルされてから不変であるのに対して、  
frameはプログラムの実行中に常に更新されます。
  
バイトコードというのは`opcode.h`に定義されている命令コードと、  
その命令コードに対応する`オペランド`がごちゃ混ぜに入ったリストです。  
(beconではそのように実装されています。)  
  
例えば、`invoke virtual`はオペランドとしてメソッドのインデックスが必要です。  

# 演算スタック
演算スタックは`関数呼び出し`や`演算子`を処理するために使用されるスタックです。  
(frame#value_stackがこの目的で使用されます。)  

# 参照スタック
参照スタックは`メソッドの実引数`や`ローカル変数`を記憶するために使用されるスタックです。
(frame#ref_stackがこの目的で使用されます。)  

# シンボルテーブル
あるローカル変数への代入/読み込みがどう実装されているかについて示します。  
  
まず、変数の宣言を見つけたらそれをシンボルテーブルへ登録します。  
(これは`symbol_table.h` にて定義されます。)  
シンボルテーブルへ変数名を登録すると、それに対応するインデックスが返ります。  
これが上述の`オペランド`、つまり命令コードの引数として利用されます。  
  
シンボルテーブルが`enviroment.h`に持たれているのは、  
これもまたコンパイルされてから不変なためです。  
(実行時に新たな変数が定義されることはないため)

# store
変数への代入は`store`命令として定義されています。  
これは整数型のインデックスが必要です。  
プログラムの流れを下記に示します。  
- バイトコードを一つ進めてインデックス=$nを取得する
- 演算スタックからポップしてオブジェクト=$objを取得
- 参照スタックの$n番目に$objを代入する。

# load
変数の読み出しは`load`命令として定義されています。
これは整数型のインデックスが必要です。  
プログラムの流れを下記に示します。  
- バイトコードを一つ進めてインデックス=$nを取得する
- 参照スタックの$n番目を演算スタックへプッシュする。
