コンパイラの実装に関するメモ  

# ASTを作成するフェーズ
yacc/bisonを使用して、  
ASTを作成します。
(ast.h ast.c .l .y lex.ccなどで行われる)

# ILを作成するフェーズ
ASTをIL(Intermediate Language=中間言語)へ変換します。  
これは手書きです。  
  
いわゆる再帰下降構文解析のような方法で解析します。  
* load_factor  
    * load_invoke  
        ここでは実引数もロードされますが、  
        実引数自体もまた factor なので、invokeの引数にinvokeを並べることが出来る。  
        つまり、実引数を読み込むために再帰的に load_factor を呼び出す。
    * load_primary  
        **primary**はそれ以上分解することが出来ない**facor**です。
        * load_int  
        * load_char
        * load_string

これは il_factor 構造体であらわされます。
公開ヘッダでは il_factor_interface.h のみインクルードできます。

ここでは簡単に計算式の変換例を示しましたが、  
同様に名前空間やクラスもILへ変換されます。  

## 名前空間の変換
名前空間は内側に名前空間自体を含めることが出来るので、  
計算式と同様に再帰的に解析されます。

## ステートメントの解析
実行可能な文のことをステートメントと呼称します。  
これはトップレベルかメソッドの内側に存在できます。  
例えばステートメントには次のものがあります。  
* ステートメント
    * **factor** ;　　
    * **factor** 改行 //これは単にセミコロンを省略しているだけです　　
    * while(condition) { ... }　　
    * if(condition) { ... }　　
    * その他...

これは il_stmt 構造体であらわされます。
公開ヘッダでは il_stmt_interface.h のみインクルードできます。


# SGを作成するフェーズ
SGという形式は単にbeaconから二文字取っただけです。  
この形式はJavaのリフレクションAPIのように、
実際のクラスや名前空間と 1 : 1 でマッピングされたオブジェクトのことです。  

* SGに属するもの  
    * namespace.h
    * type_interface.h
    * method.h
    * field.h
    * constructor.h

名前空間のルートの一覧はスクリプトコンテキストに属しています。

# クラスローダー
上記で述べてきたフェーズを実行するために、  
beaconでは**クラスローダー**を使用します。  

クラスローダーと呼んではいますが、  
実際にはファイル一つにつき一つのクラスローダーが作成され、  
import が読み込まれるたびに新しい子クラスローダーが作成されていきます。  
(一度読み込まれたファイル名をキーとしてクラスローダを保存するので、二回目以降は**作成**ではなく**参照**されます)


最初のクラスローダーは**ブートストラップクラスローダ**と呼ばれます。  
これはシステムに必要な基本型(Int, Double, Char, Array)などを  
エントリポイントよりも先にロードするためのクラスローダです。

# エントリポイントクラスローダー
mainファイルもクラスローダーによって読み込まれます。  
通常のファイルと異なるのは、トップレベルのステートメントも構文上許可される点です。  

# 循環するインクルード
beaconでは循環するインクルードを解決することが出来るようになっています。(はず。)  

循環するインクルードの例  
A.beacon  
--
    import "B"
    class MyAClass { ... }
  
B.beacon  
--
    import "A"
    class MyBClass { ... }

main.beacon  
--
    import "A"
    ...

まずブートストラップクラスローダが起動します。  
ここではA/B/mainのどれも読み込まれません。  
次に**エントリポイントクラスローダー**がmainの読み込みを開始します。

import "A" の記述を見つけたクラスローダーは  
子クラスローダーを作成して A の読み込みを開始します。  
このとき、 import "A" は "消費" されます。  
(読み込みを開始する前に)  

クラスローダは**インポートマネージャ**を持っています。  
これは**インポートインフォ**の一覧です。  
インポートインフォは既に読み込まれたかどうかを bool で持っています。  
インポート宣言の一覧を読み込むとき、既に消費されたインポートは無視されます。

なので、 B の import "A" が発見され、
Aを読み込むための 子クラスローダが **参照** されたとき、  
Aのロードが試行されますが、import "B" はここでは無視されます。

## 型宣言の読み込み
型宣言が行われたとき、既にその型がSGに存在する場合があります。
* ネイティブメソッドを登録するために登録された
* 循環するインクルードによって同じファイルが二回ロードされた

クラスローダはその型がすでに存在するかをまず確認します。  
存在しなければ作成して登録します。

次に、フィールド宣言やメソッド宣言の読み込みを**予約**します。  
もしこのクラスローダーが B であるなら、  
A を参照するソースを正しく解析することが出来ないためです。

この予約のための構造体は type_cache です。  
これも同様に既にロードされたかを表すフラグを持っています。  
(あとで書く...)
