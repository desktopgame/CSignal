# コンパイラ
beaconがソースコードを実行するまでの流れを示します。  

# ASTの作成
まず入力された文字列を`AST`へ変換します。  
これはyacc/bisonによって行われます。  
この時点では文法的なエラーだけが報告されます。  
また、メソッド呼び出しなどの文法はこの時点では`関数呼び出し演算子`の適用として判断されます。

# ILの作成
ASTを入力として中間表現である`IL`を解析します。  
これは手書きで実装されていて、再帰下降構文解析のような方法で行われます。

# インポートの解決
インポートされているファイルをまず読み込みます。  
(既に読み込まれている場合はスキップ)  
  
この時点では`名前空間`や`型`を登録するだけで、  
フィールドやメソッドは登録されません。  
  
ただし、この時点でロードするべきフィールドやメソッドを記録しておきます。  
(これは`type_cache`によって行われます。)  
  
  
また、あるファイルとそこからインポートされているファイルの一覧の対応づけも記録します。  
(これは`import_manager`によって行われます。)

# リンク
この工程は`宣言の解決`と`実装の解決`の二つのフェーズからなります。  
依存関係の深い部分からこれを実行するために、  
上述の`import_manager`を根優先で探索し、`宣言の解決`を行います。  
  
全てのファイルにおいて`宣言の解決`が行われたあと、  
同じ手順で(根優先で)`実装の解決`を行います。

既に`宣言の解決`/`実装の解決`が済んでいるのに、  
循環するインポートによって複数回解決が実行されないように、  
`型`は現在の読み込み状態を保存するフラグ変数を持っています。(type#state)

解決は`type_cache`の一覧を訪問しながら行います。  
これには何を解決するべきかという情報と既にそれが行われたかどうかのフラグが入っています。

# トップレベル
最後にエントリポイントに記述されたステートメントを読み込みます。  
エントリポイントは暗黙的に`World`クラスを`this`として扱います。  
  
そのため、トップレベルに定義された関数は全て`World`クラスに登録されます。  
ただ登録していくだけだと、  
一つのコンテキストで複数回実行した時に前回のメソッドが保持されたままになってしまいます。  
なので、まずは`World`クラスのメソッド一覧を解放してからメソッドを登録します。  
  
また、ユーザがトップレベルに直接文を書けるようにするためには  
既に`World`クラスが生成されている必要があります。  
なので、本来トップレベルに記述された処理の直前に  
{ `World`クラスを生成して`this`を置き換える処理 } を差し込みます。  
こうすることでトップレベルで`printLine`などをそのまま呼び出せます。