# gc
beacon で `gc(garbage collection)` がどう実装されるかについて示します。

# いつ実行されるか
[メソッド | コンストラクタ | 演算子オーバーロード]が終了した時に実行されます。

# アルゴリズム
マークアンドスイープをそのまま実装しています。

# スレッド
beaconはまだマルチスレッド対応していませんが、  
スレッドを表すオブジェクト`sg_thread`が存在します。  
全てのスレッドは現在実行しているスタックフレームのトップレベルを持ちます。  
(sg_thread.h # sg_thread_set_frame_ref)

# 手順
最初に生成された全てのオブジェクトのマークをクリアします。  
定数プールから参照されたオブジェクトについては特殊で、このオブジェクトのマーク状態は最後まで変更されません。  
  
次に、全てのクラスの静的変数をマークします。  
  
次に、現在実行しているスレッドを取得します。  
これは将来の変更のためにそうなっているだけで、現在では常に同じオブジェクトを返します。  
  
スレッドが持っているフレームのルートから再帰的に全てのフレームを辿り、  
`演算スタック`と`参照スタック`を`ツリーマーク`します。  
  
ツリーマークではそこから`参照される全てのオブジェクト`を再帰的にマークします。  
(無限に再帰しないように、既にマークされている場合には無視します。)  
参照される全てのオブジェクトとは、フィールドや配列の要素などが含まれます。  
  
最初に全てのオブジェクトのマークをクリアしたので、  
この時点でマークされていないオブジェクトはゴミと認識され、`スイープ`されます。  
スイープはマークされていないオブジェクトをリストから削除して解放します。  
ファイナライザは実装されていません。