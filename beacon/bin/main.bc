namespace calc {
	class Scanner {
		public:
		property String source {
			private defset;
			defget;
		}

		property Int offset {
			defset;
			defget;
		}

		def new(String source) {
			this.source = source;
			this.offset = 0;
		}

		def ready() -> Bool {
			return offset < source.length();
		}

		def ungetc() -> Void {
			offset -= 1;
		}

		def getc() -> Char {
			var ret = source.charAt(offset);
			offset += 1;
			return ret;
		}
	}
	enum TokenId {
		Value,
		Add,
		Sub,
		Mul,
		Div,
		Mod,
		LBrace,
		RBrace
	}
	class Token {
		public:
		def new(Int id, String source) {
			this.id = id;
			this.source = source;
		}

		private:
		Int id;
		String source;
	}
	class Tokenizer {
		public:
		def new(String source) {
			this.scanner = new Scanner(source);
		}

		def lex() -> Vector[Token] {
			scanner.offset = 0;
			var ret = new Vector[Token]();
			while(scanner.ready()) {
				var c = scanner.getc();
				if(c.isDigit()) {
					var buf = new StringBuilder();
					while(c.isDigit()) {
						buf << c;
						c = scanner.getc();
					}
					scanner.ungetc();
					ret << new Token(TokenId.Value, buf.toString());
				} elif (c == '+') {
					ret << new Token(TokenId.Add, "+");
				} elif (c == '-') {
					ret << new Token(TokenId.Sub, "-");
				} elif (c == '*') {
					ret << new Token(TokenId.Mul, "*");
				} elif (c == '/') {
					ret << new Token(TokenId.Div, "/");
				} elif (c == '%') {
					ret << new Token(TokenId.Div, "%");
				} elif (c == '(') {
					ret << new Token(TokenId.LBrace, "(");
				} elif (c == ')') {
					ret << new Token(TokenId.RBrace, ")");
				}
			}
		}

		private:
		Scanner scanner;
	}
	//Node
	interface Node {
		public:
		def eval() -> Int;
	}
	class ValueNode : Node {
		public:
		def new(Int value) {
			this.value = value;
		}

		def eval() -> Int {
			return value;
		}

		private:
		Int value;
	}
	abstract class BinaryOperatorNode : Node {
		public:
		def new(Node left, Node right) {
			this.left = left;
			this.right = right;
		}

		property Node left {
			private defset;
			defget;
		}
		property Node right {
			private defset;
			defget;
		}
	}
	abstract class UnaryOperatorNode : Node {
		public:
		def new(Node a) {
			this.a = a;
		}

		property Node a {
			private defset;
			defget;
		}
	}
	//operator
	class AdditiveOperator : BinaryOperatorNode {
		public:
		def new(Node left, Node right) : super(left, right) {
		}

		def eval() -> Int {
			return left.eval() + right.eval();
		}
	}
	class SubtractOperator : BinaryOperatorNode {
		public:
		def new(Node left, Node right) : super(left, right) {
		}

		def eval() -> Int {
			return left.eval() - right.eval();
		}
	}
	class MultiplyOperator : BinaryOperatorNode {
		public:
		def new(Node left, Node right) : super(left, right) {
		}

		def eval() -> Int {
			return left.eval() * right.eval();
		}
	}
	class DivideOperator : BinaryOperatorNode {
		public:
		def new(Node left, Node right) : super(left, right) {
		}

		def eval() -> Int {
			return left.eval() / right.eval();
		}
	}
	class ModOperator : BinaryOperatorNode {
		public:
		def new(Node left, Node right) : super(left, right) {
		}

		def eval() -> Int {
			return left.eval() % right.eval();
		}
	}
	class NegativeOperator : UnaryOperatorNode {
		public:
		def new(Node a) : super(a) {
		}

		def eval() -> Int {
			return -(a.eval());
		}
	}
}
var line = Console.readLine();
var sc = new calc::Scanner(line);
while(sc.ready()) {
	sc.getc().printLine();
}