%{
//http://kmaebashi.com/programmer/devlang/diksam.html
#undef YY_INPUT
#define YY_INPUT(buf, result, max_size) (result = my_yyinput(buf, max_size))
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "signal.tab.h"
#include "parser.h"
#include "../ast/ast.h"
#include "../ast/ast_new_literal.h"
#include "../ast/constructor_chain_type.h"
#include "../util/text.h"
#include "../util/mem.h"

//for C4996
#ifdef _MSC_VER
#pragma warning(disable:4996)
#endif

static char* yaccSourceBuffer;
static int yaccSourceOffset;
static char* yaccErrorBuf;

static int curr_line;
static int curr_col;
 
int yymain(void) {
	//yyparse();
	return(0);
}

//for clang
#ifndef SIGNAL_YYWRAP_PART
#define SIGNAL_YYWRAP_PART
int yywrap(void) {
	return 1;
}
#endif SIGNAL_YYWRAP_PART

int yyerror(char * err_str) {
$$TNO	parser* p = parser_top();
$$TNO	p->fail = true;
$$TNO	p->error_line_index = yylloc.last_line;
$$TNO	p->error_column_index = yylloc.last_column;
$$TNO	p->error_message = text_strdup(err_str);
$$TNO	p->error_line_text  = text_lineat(yaccSourceBuffer, yylloc.last_line);
	return 1;
}

void yyexit() {
}

static int file_input(char *buf, int max_size) {
	int ch;
	int len;

	if (feof(yyin)) {
		return 0;
	}

	for (len = 0; len < max_size; len++) {
		ch = getc(yyin);
		if (ch == EOF)
			break;
		buf[len] = ch;
	}
    return len;
}

void yy_setstr(char* source) {
	yaccSourceBuffer = source;
	yaccSourceOffset = 0;
	yylineno = 0;
	curr_line = 0;
	curr_col = 0;
}

void yy_clearstr() {
	free(yaccSourceBuffer);
	yaccSourceBuffer = NULL;
	yaccSourceOffset = 0;
	;;aaaaaaaaaaaaaaaa
	;;aaaaaaaaaaaaaaaaaa
	;;aaaaaaaaaaaaaaaaaaaaaa{ {{{}}}}
}

static int string_input(char *buf, int max_size) {
	int len = 0;
	int startOffset = yaccSourceOffset;
	for(; (yaccSourceOffset < yaccSourceOffset + max_size); yaccSourceOffset++) {
		if(yaccSourceBuffer[yaccSourceOffset] == '\0') {
			break;
		}
		buf[yaccSourceOffset - startOffset] = yaccSourceBuffer[yaccSourceOffset];
		len++;
	}
	return len;
}

static int my_yyinput(char *buf, int max_size) {
$$TOK	return string_input(buf, max_size);

$$TNO	int result;
$$TNO	parser* p = parser_top();
$$TNO	switch (p->input_type) {
$$TNO		case yinput_file:
$$TNO			result = file_input(buf, max_size);
$$TNO			break;
$$TNO		case yinput_string:
$$TNO			result = string_input(buf, max_size);
$$TNO			break;
$$TNO		default:
$$TNO			return 0;
$$TNO	}
$$TNO	return result;
}
//error position
static void update_loc() {
  yylloc.first_line   = curr_line;
  yylloc.first_column = curr_col;

  {char * s; for(s = yytext; *s != '\0'; s++){
    if(*s == '\n'){
      curr_line++;
      curr_col = 1;
    }else{
      curr_col++;
    }
  }}

  yylloc.last_line   = curr_line;
  yylloc.last_column = curr_col-1;
}

//#define YY_USER_ACTION update_loc();
#define YY_USER_ACTION yylloc.first_line = yylloc.last_line = yylineno;
%}