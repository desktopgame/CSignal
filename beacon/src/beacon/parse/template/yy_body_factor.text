expression
	: LRB expression RRB
	{
		$$ = $2;
	}
	| primary
	|  expression_nobrace
	;
$$SET __SELF expression
expression_nobrace
	: ADD __SELF %prec POSITIVE
	{
		$$ = ast_new_unary(ast_pos, $2);
	}
	| SUB __SELF %prec NEGATIVE
	{
		$$ = ast_new_unary(ast_neg, $2);
	}
	| __SELF ADD __SELF
	{
		$$ = ast_new_binary(ast_add, $1, $3);
	}
	| __SELF SUB __SELF
	{
		$$ = ast_new_binary(ast_sub, $1, $3);
	}
	| __SELF MUL __SELF
	{
		$$ = ast_new_binary(ast_mul, $1, $3);
	}
	| __SELF DIV __SELF
	{
		$$ = ast_new_binary(ast_div, $1, $3);
	}
	| __SELF MOD __SELF
	{
		$$ = ast_new_binary(ast_mod, $1, $3);
	}
	| __SELF BIT_OR __SELF
	{
		$$ = ast_new_binary(ast_bit_or, $1, $3);
	}
	| __SELF EQUAL __SELF
	{
		$$ = ast_new_binary(ast_equal, $1, $3);
	}
	| __SELF NOTEQUAL __SELF
	{
		$$ = ast_new_binary(ast_notequal, $1, $3);
	}
	| __SELF BIT_AND __SELF
	{
		$$ = ast_new_binary(ast_bit_and, $1, $3);
	}
	| __SELF EXC_OR __SELF
	{
		$$ = ast_new_binary(ast_exc_or, $1, $3);
	}
	| __SELF LOGIC_OR __SELF
	{
		$$ = ast_new_binary(ast_logic_or, $1, $3);
	}
	| __SELF LOGIC_AND __SELF
	{
		$$ = ast_new_binary(ast_logic_and, $1, $3);
	}
	| lhs ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_assign, $1, $3);
	}
	| lhs ADD_ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_add_assign, $1, $3);
	}
	| lhs SUB_ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_sub_assign, $1, $3);
	}
	| lhs MUL_ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_mul_assign, $1, $3);
	}
	| lhs DIV_ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_div_assign, $1, $3);
	}
	| lhs MOD_ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_mod_assign, $1, $3);
	}
	| lhs AND_ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_and_assign, $1, $3);
	}
	| lhs OR_ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_or_assign, $1, $3);
	}
	| lhs EXC_OR_ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_exc_or_assign, $1, $3);
	}
	| lhs LSHIFT_ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_lshift_assign, $1, $3);
	}
	| lhs RSHIFT_ASSIGN __SELF
	{
		$$ = ast_new_binary(ast_rshift_assign, $1, $3);
	}
	| __SELF GT __SELF
	{
		$$ = ast_new_binary(ast_gt, $1, $3);
	}
	| __SELF GE __SELF
	{
		$$ = ast_new_binary(ast_ge, $1, $3);
	}
	| __SELF LT __SELF
	{
		$$ = ast_new_binary(ast_lt, $1, $3);
	}
	| __SELF LE __SELF
	{
		$$ = ast_new_binary(ast_le, $1, $3);
	}
	| __SELF LSHIFT __SELF
	{
		$$ = ast_new_binary(ast_lshift, $1, $3);
	}
	| __SELF RSHIFT __SELF
	{
		$$ = ast_new_binary(ast_rshift, $1, $3);
	}
	| __SELF INSTANCEOF typename_T
	{
		$$ = ast_new_instanceof($1, $3);
	}
	| __SELF AS typename_T
	{
		$$ = ast_new_as($1, $3);
	}
	| CHILDA __SELF
	{
		$$ = ast_new_unary(ast_childa, $2);
	}
	| NOT __SELF
	{
		$$ = ast_new_unary(ast_not, $2);
	}
	| expression_nobrace LRB argument_list RRB %prec FUNCCALL
	{
		$$ = ast_new_op_call($1, $3);
	}
	| expression_nobrace LRB RRB %prec FUNCCALL
	{
		$$ = ast_new_op_call($1, ast_new_blank());
	}
	| NEW fqcn_part typename_group LRB argument_list RRB
	{
		$$ = ast_new_new_instance($2, $3, $5);
	}
	| NEW fqcn_part typename_group LRB RRB
	{
		$$ = ast_new_new_instance($2, $3, ast_new_blank());
	}
	| THIS_TOK
	{
		$$ = ast_new_this();
	}
	| SUPER_TOK
	{
		$$ = ast_new_super();
	}
	| lhs
	;
lhs
	: fqcn_part typename_group
	{
		$$ = ast_new_variable($1, $2);
	}
	| __SELF DOT IDENT typename_group
	{
		$$ = ast_new_field_access($1, $3, $4);
	}
	;;+-*/%
	| __SELF DOT ADD LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_add, $5);
	}
	| __SELF DOT SUB LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_sub, $5);
	}
	| __SELF DOT MUL LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_mul, $5);
	}
	| __SELF DOT DIV LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_div, $5);
	}
	| __SELF DOT MOD LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_mod, $5);
	}
	;;> >= < <=
	| __SELF DOT GT LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_gt, $5);
	}
	| __SELF DOT GE LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_ge, $5);
	}
	| __SELF DOT LT LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_lt, $5);
	}
	| __SELF DOT LE LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_le, $5);
	}
	;;== !=
	| __SELF DOT EQUAL LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_eq, $5);
	}
	| __SELF DOT NOTEQUAL LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_noteq, $5);
	}
	;;| &
	| __SELF DOT BIT_OR LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_bit_or, $5);
	}
	| __SELF DOT BIT_AND LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_bit_and, $5);
	}
	;;|| &&
	| __SELF DOT LOGIC_OR LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_logic_or, $5);
	}
	| __SELF DOT LOGIC_AND LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_logic_and, $5);
	}
	;;<< >>
	| __SELF DOT LSHIFT LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_lshift, $5);
	}
	| __SELF DOT RSHIFT LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_rshift, $5);
	}
	;;^
	| __SELF DOT EXC_OR LRB __SELF RRB
	{
		$$ = ast_new_explicit_bioperator($1, operator_excor, $5);
	}
	;;!
	| __SELF DOT NOT LRB RRB
	{
		$$ = ast_new_explicit_uoperator($1, operator_not);
	}
	;;~
	| __SELF DOT CHILDA LRB RRB
	{
		$$ = ast_new_explicit_uoperator($1, operator_childa);
	}
	| __SELF DOT SUB LRB RRB
	{
		$$ = ast_new_explicit_uoperator($1, operator_negative);
	}
	;
$$REM __SELF
primary
	: INT
	| DOUBLE
	| CHAR_LITERAL
	| STRING_LITERAL
	| TRUE_TOK
	{
		$$ = ast_new_true();
	}
	| FALSE_TOK
	{
		$$ = ast_new_false();
	}
	| NULL_TOK
	{
		$$ = ast_new_null();
	}
	;
