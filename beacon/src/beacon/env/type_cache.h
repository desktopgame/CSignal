//BEGIN-AUTOGENERATED-BLOCK
/**
 * @file type_cache.h
 * @brief クラスロード時に一時的に使用されるキャッシュを定義します。
 * @author koya
 * @date 2018/10/31
 */
//END-AUTOGENERATED-BLOCK

#pragma once
#ifndef BEACON_ENV_TYPE_CACHE_H
#define BEACON_ENV_TYPE_CACHE_H
#include "../il/il_type_interface.h"
#include "type_interface.h"
#include "namespace.h"
struct bc_ClassLoader;
//#include "class_loader.h"

/**
 * 何を読み込むためのキャッシュかを表す列挙型.
 */
typedef enum bc_TypeCacheKind {
	CACHEKIND_CLASS_DECL_T,
	CACHEKIND_CLASS_IMPL_T,

	CACHEKIND_INTERFACE_DECL_T,
	CACHEKIND_INTERFACE_IMPL_T,

	CACHEKIND_ENUM_DECL_T,
	CACHEKIND_ENUM_IMPL_T,
} bc_TypeCacheKind;

/**
 * クラスロード時に使用される一時的なキャッシュです.
 * signalクラスローダーは循環参照を正しく読み込むために、
 *
 * import先のファイルを解釈するときに
 * そのファイルの宣言情報だけを最初にロード(宣言ロード)して
 * import元のファイルへ戻ります。
 * import元のファイルをロードしたら上述のファイル全てで、
 * その実装情報をロードします。
 * つまり宣言ロード時に予約された実装の読み込みが必要な情報を表すキャッシュです。
 */
typedef struct bc_TypeCache {
	struct bc_ClassLoader* Context;
	bc_ILType* ILType;
	bc_Type* Type;
	bc_Namespace* Scope;
	bc_TypeCacheKind Kind;
	bool IsConsume;
} bc_TypeCache;

bc_TypeCache* bc_NewTypeCache();

bc_TypeCache * bc_InitTypeCache(
	bc_TypeCache* self,
	struct bc_ClassLoader* context,
	bc_ILType* iltype,
	bc_Type* tp,
	bc_Namespace* scope,
	bc_TypeCacheKind kind
	);

void bc_DeleteTypeCache(bc_TypeCache* self);
#endif // !SIGNAL_ENV_TYPE_CACHE_H
