//BEGIN-AUTOGENERATED-BLOCK
/**
 * @file class_impl.h
 * @brief クラスを定義します。
 * @author koya
 * @date 2018/10/31
 */
//END-AUTOGENERATED-BLOCK

#pragma once
#ifndef BEACON_ENV_CLASS_H
#define BEACON_ENV_CLASS_H
#include "../namespace.h"
#include "../native_method_ref.h"
#include "../vtable.h"
#include "../type_interface.h"
#include "../../ast/operator_type.h"
#include "../../vm/enviroment.h"
#include "../../util/vector.h"
#include "../../il/call_context.h"
#include "../../util/numeric_map.h"
#include "../../util/string_pool.h"
#include "../operator_vt.h"
#include "class_validate.h"
//#include "../access_domain.h"
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
//struct field_list;
//struct method_list;
struct bc_Object;
struct bc_Field;
struct bc_Property;
struct bc_PropertyBody;
struct bc_Method;
struct bc_Constructor;
struct bc_GenericType;
struct bc_OperatorOverload;
/**
 * クラスを表す構造体です.
 */
typedef struct bc_Class {
	bc_Type* Parent;
	StringView Name;
	bc_Namespace* Location;
	struct bc_GenericType* SuperClass;
	Vector* Implements;
	Vector* Fields;
	Vector* StaticFields;
	Vector* Properties;
	Vector* StaticProperties;
	Vector* Methods;
	Vector* StaticMethods;
	Vector* Constructors;
	Vector* OperatorOverloads;
	//class_type type;
	uint32_t RefCount;
	NumericMap* NativeMethodRefMap;
	Vector* TypeParameters;
	//インターフェースに対応した
	//実装メソッドのテーブルのベクター
	//http://d.hatena.ne.jp/tetz42/20120205/1328449750
	Vector* VTTable;
	//Vector* static_fieldval_vec;
	bc_VTable* VT;
	bc_OperatorVT* OVT;
	bool IsAbstract;
} bc_Class;
#include "class_find.h"

/**
 * クラスをスーパーセットにラップします.
 * @param self
 * @return
 */
bc_Type* bc_WrapClass(bc_Class* self);

/**
 * 新しいクラスを作成します.
 * 呼び出し側で対応する名前空間を紐づけてください。
 * @param namev
 * @return
 */
bc_Class* bc_NewClass(StringView namev);

/**
 * 指定のインターフェイスを実装するクラスを作成します.
 * @param gt
 * @param namev
 * @return
 */
bc_Class* bc_NewClassProxy(struct bc_GenericType* gt, StringView namev);

/**
 * 事前に読みこまれる必要があるクラスを作成します.
 * @param namev
 */
bc_Type* bc_NewPreloadClass(StringView namev);

/**
 * 指定のオブジェクトにこのクラスのフィールドを表す
 * オブジェクトの一覧を追加します。
 * この関数は親クラスから順番に呼び出してください。
 * 以下の副作用をもたらします。
 * - o->classz は self で上書きされます。
 * - o->vptr は self->vt で上書きされます。
 * @param self
 * @param o
 * @param fr
 */
void bc_AllocFieldsClass(bc_Class* self, struct bc_Object* o, Frame* fr);

/**
 * 指定のオブジェクトに追加されたフィールドの一覧を開放します.
 * このメソッドは子クラスから順番に呼び出してください。
 * @param self
 * @param o
 */
void bc_FreeClassFields(bc_Class* self, struct bc_Object* o);

/**
 * このクラスにフィールドを追加します.
 * @param self
 * @param f
 */
void bc_AddFieldClass(bc_Class* self, struct bc_Field* f);

/**
 * このクラスにプロパティを追加します.
 * @param self
 * @param p
 */
void bc_AddPropertyClass(bc_Class* self, struct bc_Property* p);

/**
 * このクラスにメソッドを追加します.
 * @param self
 * @param m
 */
void bc_AddMethodClass(bc_Class* self, struct bc_Method* m);

/**
 * このクラスにコンストラクタを追加します.
 * @param self
 * @param c
 */
void bc_AddConstructorClass(bc_Class* self, struct bc_Constructor* c);

/**
 * 指定の名前に対応するネイティブ関数を登録します.
 * @param self
 * @param name
 * @param impl
 */
void bc_DefineNativeMethodClass(bc_Class* self, const char* name, bc_NativeImpl impl);

/**
 * 指定の名前に対応するネイティブ関数を登録します.
 * @param self
 * @param namev
 * @param impl
 */
void bc_DefineNativeMethodByRefClass(bc_Class* self, StringView namev, bc_NativeImpl impl);

/**
 * super と sub の距離を返します.
 * @param super
 * @param sub
 * @return 同じクラスなら 0
 *         otherがselfのサブクラスなら正の数(階層の深さ)
 *         継承関係が異なるなら -1
 */
int bc_DistanceClass(bc_Class* super, bc_Class* sub);

/**
 * このクラスの VTable を、現在のメソッド一覧に基づいて作成します.
 * このメソッドが呼び出されるまでメンバの vt は NULL です。
 * また、この関数は全てのメソッドが登録されてから呼び出してさい。
 * @param self
 */
void bc_CreateVTableClass(bc_Class* self);
/**
 * このクラスの operator_Vt を、現在のメソッド一覧に基づいて作成します.
 * @param self
 */
void bc_CreateOperatorVTClass(bc_Class* self);

/**
 * このクラスとその親全てに定義されたフィールドの合計を返します.
 * @param self
 * @return
 */
int bc_CountAllFieldClass(bc_Class* self);

/**
 * このクラスとその親全てに定義された静的フィールドの合計を返します.
 * @param self
 * @return
 */
int bc_CountAllSFieldClass(bc_Class* self);

/**
 * このクラスとその親全てに定義されたプロパティの合計を返します.
 * @return
 */
int bc_CountAllPropertyClass(bc_Class* self);

/**
 * このクラスとその親全てに定義された静的プロパティの合計を返します.
 * @param self
 * @return
 */
int bc_CountAllSPropertyClass(bc_Class* self);

/**
 * このクラスとその親全てに定義されたメソッドの合計を返します.
 * @param self
 * @return
 */
int bc_CountAllMethodClass(bc_Class* self);

/**
 * このクラスとその親全てに定義されたメソッドの合計を返します.
 * @param self
 * @return
 */
int bc_CountAllSMethodClass(bc_Class* self);

/**
 * @param self
 * @param ilctx
 * @param fr
 * @param count
 * @param args
 * @param type_args
 * @return
 */
struct bc_Object* bc_NewInstanceClass(bc_Class* self, Frame* fr, Vector* args, Vector* type_args);

/**
 * 全てのメンバーがこのクラスを参照できるようにします.
 * @param self
 */
void bc_LinkAllClass(bc_Class* self);

/**
 * 型情報を残してメソッドやフィールドなどのみを開放します.
 * @param self
 */
void bc_UnlinkClass(bc_Class* self);

/**
 * このクラスを開放します.
 * ただし先にこのクラスを参照するサブクラスを開放する必要があります。
 * @param self
 */
void bc_DeleteClass(bc_Class* self);
#endif // !SIGNAL_ENV_CLASS_H
